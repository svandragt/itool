#!/usr/bin/env bash
set -euo pipefail

## Notes on this script
# Registry remains minimal: only path and port.
# Ports are auto-assigned on register from 8600–8999 (adjustable inside the script).
# docker-compose.override.yml is generated per project and should be treated as machine-local (do not commit).
# The tool’s URL is printed as http://<name>.local:<host_port>; if you later enable wildcard DNS, you can change just the printed hostname without touching registration logic.


CONFIG_DIR="${HOME}/.config/itools"
REGISTRY="${CONFIG_DIR}/registry.ini"

PORT_RANGE_START_DEFAULT=8600
PORT_RANGE_END_DEFAULT=8999

usage() {
  cat <<'EOF'
usage:
  itool register <name> <path> [--port N]
  itool edit-registry
  itool sync
  itool list
  itool info <name>

  itool <name> {up|down|restart|logs|build|ps|path}

notes:
  - registry is ~/.config/itools/registry.ini (INI sections per tool)
  - each tool section contains only:
      path = /absolute/path
      port = <host_port>
  - project must define container port as PORT in its .env (no guessing)
  - sync generates docker-compose.override.yml per project (DO NOT COMMIT)
EOF
  exit 1
}

ensure_dirs() {
  mkdir -p "$CONFIG_DIR"
  [[ -f "$REGISTRY" ]] || touch "$REGISTRY"
}

require_compose() {
  command -v docker >/dev/null || { echo "docker not found in PATH" >&2; exit 3; }
  docker compose version >/dev/null || { echo "docker compose v2 required" >&2; exit 3; }
}

valid_name() {
  local name="$1"
  [[ "$name" =~ ^[a-zA-Z0-9][a-zA-Z0-9_-]*$ ]]
}

# --- INI helpers (minimal parser) ---

ini_get() {
  # ini_get <section> <key>
  # prints value or empty
  local section="$1" key="$2"
  awk -v sec="[$section]" -v key="$key" '
    $0 ~ "^[[:space:]]*\\[" { insec = ($0==sec) }
    insec && $0 ~ "^[[:space:]]*"key"[[:space:]]*=" {
      sub("^[^=]*=[[:space:]]*", "", $0)
      print $0
      exit
    }
  ' "$REGISTRY"
}

ini_has_section() {
  local section="$1"
  grep -qE "^[[:space:]]*\\[${section}\\][[:space:]]*$" "$REGISTRY"
}

ini_set_kv() {
  # ini_set_kv <section> <key> <value>
  local section="$1" key="$2" value="$3"

  if ! ini_has_section "$section"; then
    {
      echo
      echo "[$section]"
      echo "$key = $value"
    } >> "$REGISTRY"
    return
  fi

  # If key exists inside section, replace it; otherwise append within section.
  # We'll rewrite file for correctness.
  awk -v sec="[$section]" -v key="$key" -v val="$value" '
    function trim(s){ sub(/^[ \t]+/,"",s); sub(/[ \t]+$/,"",s); return s }
    BEGIN{ insec=0; done=0 }
    /^[ \t]*\[/ {
      if(insec && !done){
        print key" = "val
        done=1
      }
      insec = ($0==sec)
      print
      next
    }
    {
      if(insec){
        line=$0
        split(line, parts, "=")
        k=trim(parts[1])
        if(k==key){
          if(!done){
            print key" = "val
            done=1
          }
          next
        }
      }
      print
    }
    END{
      if(insec && !done){
        print key" = "val
      }
    }
  ' "$REGISTRY" > "${REGISTRY}.tmp"
  mv "${REGISTRY}.tmp" "$REGISTRY"
}

ini_list_sections() {
  awk '/^[[:space:]]*\[[^]]+\][[:space:]]*$/ { gsub(/^[[:space:]]*\[/,""); gsub(/\][[:space:]]*$/,""); print }' "$REGISTRY"
}

# --- port allocation / checks ---

port_in_registry() {
  local port="$1"
  awk -v p="$port" '
    /^[[:space:]]*port[[:space:]]*=/ {
      sub("^[^=]*=[[:space:]]*", "", $0)
      if($0==p){ found=1 }
    }
    END{ exit(found?0:1) }
  ' "$REGISTRY"
}

port_in_use() {
  local port="$1"
  # Prefer ss if available.
  if command -v ss >/dev/null; then
    ss -ltn 2>/dev/null | awk '{print $4}' | grep -qE "(:|\\])${port}$"
  else
    # Fallback to lsof if ss missing.
    command -v lsof >/dev/null || return 1
    lsof -iTCP -sTCP:LISTEN -nP 2>/dev/null | awk '{print $9}' | grep -qE "(:|\\])${port}$"
  fi
}

alloc_port() {
  local start="$1" end="$2"
  local p
  for ((p=start; p<=end; p++)); do
    if port_in_registry "$p"; then
      continue
    fi
    if port_in_use "$p"; then
      continue
    fi
    echo "$p"
    return 0
  done
  echo "no free port found in range ${start}-${end}" >&2
  exit 4
}

# --- override generation ---

write_override() {
  # write_override <tool_name> <project_dir> <host_port>
  local name="$1" dir="$2" host_port="$3"
  local f="${dir}/docker-compose.override.yml"

  cat > "$f" <<EOF
# Generated by itool (machine-local). DO NOT COMMIT.
services:
  app:
    ports:
      - "${host_port}:\${PORT}"
EOF
}

# --- sync / validation ---

sync_all() {
  ensure_dirs
  local sec
  while IFS= read -r sec; do
    [[ -n "$sec" ]] || continue
    local path port
    path="$(ini_get "$sec" path || true)"
    port="$(ini_get "$sec" port || true)"

    if [[ -z "${path:-}" || -z "${port:-}" ]]; then
      echo "sync: skip [$sec] (missing path or port)" >&2
      continue
    fi
    if [[ ! -d "$path" ]]; then
      echo "sync: skip [$sec] (path not found: $path)" >&2
      continue
    fi
    write_override "$sec" "$path" "$port"
  done < <(ini_list_sections)
}

registry_validate() {
  ensure_dirs
  local seen_ports=""
  local sec
  while IFS= read -r sec; do
    [[ -n "$sec" ]] || continue
    local path port
    path="$(ini_get "$sec" path || true)"
    port="$(ini_get "$sec" port || true)"

    if [[ -z "${path:-}" ]]; then
      echo "registry: [$sec] missing path" >&2
      exit 2
    fi
    if [[ -z "${port:-}" || ! "$port" =~ ^[0-9]+$ ]]; then
      echo "registry: [$sec] missing/invalid port" >&2
      exit 2
    fi
    if [[ ! -d "$path" ]]; then
      echo "registry: [$sec] path not found: $path" >&2
      exit 2
    fi
    if grep -qE "(^|[[:space:]])${port}($|[[:space:]])" <<<"$seen_ports"; then
      echo "registry: duplicate port ${port} (found at [$sec])" >&2
      exit 2
    fi
    seen_ports="${seen_ports} ${port}"

    # Warn (not fail) if port is currently in use (it might be your tool running).
    if port_in_use "$port"; then
      :
    fi
  done < <(ini_list_sections)
}

# --- tool resolution ---

resolve_tool() {
  local name="$1"
  ensure_dirs
  ini_has_section "$name" || { echo "unknown tool: $name" >&2; exit 2; }
  local path port
  path="$(ini_get "$name" path || true)"
  port="$(ini_get "$name" port || true)"
  [[ -n "${path:-}" && -d "$path" ]] || { echo "invalid path in registry for [$name]" >&2; exit 2; }
  [[ -n "${port:-}" ]] || { echo "missing port in registry for [$name]" >&2; exit 2; }
  echo "${path}|${port}"
}

require_project_port_env() {
  # must define PORT in .env; we do not guess
  [[ -f .env ]] || { echo "missing .env in project (required): $(pwd)" >&2; exit 2; }
  grep -qE '^[[:space:]]*PORT=' .env || { echo "missing PORT=... in .env (required): $(pwd)/.env" >&2; exit 2; }
}

open_url() {
  local url="$1"
  command -v xdg-open >/dev/null && xdg-open "$url" >/dev/null 2>&1 || true
}

# --- commands ---

cmd_register() {
  ensure_dirs
  [[ $# -ge 2 ]] || usage

  local name="$1" path="$2"; shift 2
  valid_name "$name" || { echo "invalid name: $name" >&2; exit 2; }
  [[ -d "$path" ]] || { echo "path not found: $path" >&2; exit 2; }

  local wanted_port=""
  while [[ $# -gt 0 ]]; do
    case "$1" in
      --port)
        shift
        [[ $# -gt 0 ]] || { echo "--port requires a value" >&2; exit 2; }
        wanted_port="$1"
        ;;
      *)
        echo "unknown option: $1" >&2; exit 2 ;;
    esac
    shift
  done

  local port
  if [[ -n "$wanted_port" ]]; then
    [[ "$wanted_port" =~ ^[0-9]+$ ]] || { echo "invalid port: $wanted_port" >&2; exit 2; }
    if port_in_registry "$wanted_port"; then
      echo "port already assigned in registry: $wanted_port" >&2; exit 2
    fi
    if port_in_use "$wanted_port"; then
      echo "port is currently in use on this machine: $wanted_port" >&2; exit 2
    fi
    port="$wanted_port"
  else
    port="$(alloc_port "$PORT_RANGE_START_DEFAULT" "$PORT_RANGE_END_DEFAULT")"
  fi

  # Write registry entries
  ini_set_kv "$name" path "$path"
  ini_set_kv "$name" port "$port"

  # Generate override
  write_override "$name" "$path" "$port"

  echo "registered: $name"
  echo "  path: $path"
  echo "  host port: $port"
  echo "  override: $path/docker-compose.override.yml"
}

cmd_edit_registry() {
  ensure_dirs
  local editor="${EDITOR:-nano}"
  "$editor" "$REGISTRY"
  registry_validate
  sync_all
  echo "registry saved and overrides synced"
}

cmd_list() {
  ensure_dirs
  local sec
  while IFS= read -r sec; do
    [[ -n "$sec" ]] || continue
    local path port
    path="$(ini_get "$sec" path || true)"
    port="$(ini_get "$sec" port || true)"
    printf "%-20s  %5s  %s\n" "$sec" "$port" "$path"
  done < <(ini_list_sections)
}

cmd_info() {
  ensure_dirs
  [[ $# -eq 1 ]] || usage
  local name="$1"
  ini_has_section "$name" || { echo "unknown tool: $name" >&2; exit 2; }
  local path port
  path="$(ini_get "$name" path || true)"
  port="$(ini_get "$name" port || true)"
  echo "name: $name"
  echo "path: $path"
  echo "host port: $port"
}

# --- main dispatch ---

[[ $# -ge 1 ]] || usage
ensure_dirs

case "$1" in
  register)
    shift; cmd_register "$@"; exit 0 ;;
  edit-registry)
    shift; cmd_edit_registry; exit 0 ;;
  sync)
    shift; registry_validate; sync_all; echo "overrides synced"; exit 0 ;;
  list)
    shift; cmd_list; exit 0 ;;
  info)
    shift; cmd_info "$@"; exit 0 ;;
esac

# Tool lifecycle commands: itool <name> up|down|...
[[ $# -ge 2 ]] || usage
NAME="$1"; ACTION="$2"

require_compose
IFS="|" read -r DIR HOST_PORT <<<"$(resolve_tool "$NAME")"
export COMPOSE_PROJECT_NAME="itool_${NAME}"

cd "$DIR"
require_project_port_env

# Always ensure override exists and matches current registry port
write_override "$NAME" "$DIR" "$HOST_PORT"

case "$ACTION" in
  up)
    docker compose up -d --build
    echo "Open: http://${NAME}.local:${HOST_PORT}"
    open_url "http://${NAME}.local:${HOST_PORT}"
    ;;
  down)
    docker compose down
    ;;
  restart)
    if ! docker compose ps --status running --services | grep -q .; then
      docker compose up -d --build
    else
      docker compose restart || docker compose up -d
    fi
    echo "Open: http://${NAME}.local:${HOST_PORT}"
    ;;
  logs)
    exec docker compose logs -f
    ;;
  build)
    docker compose build
    ;;
  ps)
    docker compose ps
    ;;
  path)
    echo "$DIR"
    ;;
  *)
    usage
    ;;
esac
